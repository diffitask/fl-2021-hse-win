# Формальные языки
## Домашнее задание №4

#### Задание 0
*«Придумать язык для описания конечных автоматов»*

Описание на естественном языке:

По аналогии с определением конечного детерминированного автомата, учитывая, что автомат схож с графом, автомат будем описывать следующими параметрами (каждый параметр записывается на отдельной строке, после мощности/ количества идет дефис):
1. Мощность алфавита, затем перечисление всех его символов
2. Мощность множества состояний
3. Начальное состояние, то есть номер вершины графа, соответствующей ей (или 0, если стартовая вершина отсутствует)
4. Стоковая вершина (или 0, если стоковая вершина отсутствует)
5. Мощность множества терминальных вершин, затем перечисление номеров всех терминальных вершин
6. Количество переходов между состояниями, затем перечисление всех ребер-переходов между состояниями. Ребро описывается своей начальной и конечной вершинами, а также набором символов из алфавита, с помощью которых осуществляется этот переход.

Нумерация вершин начинается с единицы. Вершина с номером ноль зарезервирована для обозначения несуществующего состояния -- если в автомате отсутсвует сток или стартовая вершина, на соответствующей строке вводится 0.

Символы алфавита оборачиваются в двойные кавычки `"..."`, тем самым у пользователя появляется возможность сделать символом любую последовательность char-ов. Чтобы лексер различал случаи использования спецсимволов от последовательности символьного типа, непосредственно саму кавычку `"` и обратный слеш `\` будем экранировать: `"\""`, `"\\"`.

**Пример 1**

Автомат, принимающий стоки, состоящие из букв a и b.
```
 Alphabet: 2 -- ("a", "b")
 Q: 2
 start: 1
 runoff: 0
 T: 1 -- 2
 edges: (1; 2; "a", "b")
```
**Пример 2**

Автомат, принимающий неотрицательные числа, делящиеся на 3 (лидирующие нули разрешаются).
```
Alphabet: 10 -- ("1", "2", "3", "4", "5", "6", "7", "8", "9")
Q: 3
start: 1
runoff: 0
T: 1 -- 2
edges: (1; 1; "0", "3", "6", "9"), (1; 2; "1", "4", "7"), (2; 1; "2", "5", "8"), (2; 2; "0", "3", "6", "9"), (2; 3; "1", "4", "7"), (3; 2; "2", "5", "8"), (3; 3; "0", "3", "6", "9"), (3; 1; "1", "4", "7"), (1; 3; "2", "5", "8")
```
**Пример 3**

Автомат, принимающий числа, в записи которых встречаются только четные цифры (лидирующие нули разрешаются).
```
Alphabet: 10 -- ("1", "2", "3", "4", "5", "6", "7", "8", "9")
Q: 4
start: 1
runoff: 0
T: 1 -- 1
edges: (1; 2; "0", "2", "4", "6", "8"), (2; 2; "0", "2", "4", "6", "8"), (2; 3; "1", "3", "5", 7", "9"), (1; 3; "1", "3", "5", 7", "9"), (3; 4; "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"), (4; 4; "0", "1", "2", "3", "4", "5", "6", "7", "8", "9")
```

#### Задание 1

##### Отчет по языку описания конечных автоматов Боброва Олега

Язык подробно и хорошо описан. Визуально выглядит красиво, читабельно, user friendly. В начале каждой строки перед перечислением вершин или символов с помощью ключевых слов (таких, как, например, setAlphabet) объясняется, ввод каких данных сейчас будет происходить, что является удобной формой представления для пользователя.

Примеры автоматов на предложенном языке:

**Example 1:**
```
setAlphabet: "a, b"
setStates: "q0, q1"
setStart: "q0"
makeTerminate: "q0"
addEdge: "q0, q1, a"
addEdge: "q0, q1, b"
addEdge: "q1, q1, a"
addEdge: "q1, q1, b"
```
**Example 2 -- автомат, принимающий строки, состоящие из букв *a***
```
setAlphabet: "a"
setStates: "q0, q1"
setStart: "q0"
makeTerminate: "q1"
addEdge: "q0, q1, a"
addEdge: "q1, q1, a"
```

В языке есть недочет: в предложенном описании на ребрах перехода может стоять только один символ, в то время как автоматы, для которых возможны переходы из одного состояния в другое по нескольким символам алфавита, будут обрабатываться некорректно.

В языке, с моей точки зрения, есть недочет: если на ребре перехода стоит несколько символов, то приходится создавать несколько строк, описывающих одно и то же ребро, и на каждой строке вводить только один новый символ перехода. Как можно было бы изменить -- при вводе команды `addEdge` перечислять через запятую все символы перехода, начиная с третьей позиции.

Пример, как можно изменить описание ребра -- прежнее описание:
```
setAlphabet: "0, 1, 2, 3"
setStatesAmount: 2
setStart: 0
makeTerminate: 0
addEdge: "0, 1, 0"
addEdge: "0, 1, 1"
addEdge: "1, 1, 0"
addEdge: "1, 1, 1"
```

Пример измененного ввода ребер:
```
setAlphabet: "0, 1, 2, 3"
setStatesAmount: 2
setStart: 0
makeTerminate: 0
addEdge: "0, 1, 0, 1"
addEdge: "1, 1, 0, 1"
```

Еще один момент, который не всегда учитывается языком: если пользователь в качестве символа алфавита захотел ввести "a, b" (буква - запятая - пробел - буква), то текущая версия парсера скажет, что это две буквы -- *a* и *b*.

Пример некорректного ввода данных:
```
setAlphabet: "a, b"
setStates: "q0, q1"
setStart: "q0"
makeTerminate: "q0"
addEdge: "q0, q1, a, b"
```

Как можно было бы изменить: каждый символ алфавита заключать в кавычки, тогда ввод данных происходил бы следующим образом:
```
setAlphabet: "a", "b"
setStates: "q0, q1"
setStart: "q0"
makeTerminate: "q0"
addEdge: "q0, q1", "a", "b"
```

И еще нюанс. В языке нет строки, которая задавала бы стоковое состояние. Чтобы его определить, придется либо визуализировать автомат, либо как-то проходиться по всем состояниям. Хотелось бы сразу ввести, например, строку `runoff`, в которой задавался бы номер стоковой вершины.

Пример добавления стоковой вершины:
```
setAlphabet: "a", "b"
setStates: "q0, q1"
setStart: "q0"
makeTerminate: "q0"
setRunoff: "q1"
addEdge: "q0, q1", "a", "b"
```

Сам по себе язык хороший, выполнена удобная поддержка в среде разработки, качественная работа, в общем)

##### Отчет по языку описания конечных автоматов Трофимовой Кристины
Язык хорошо описан, приведены хорошие примеры, есть наглядное представление автоматов. В качестве недочета, как описано выше про язык Олега Боброва, можно выявить следующее -- не вводится стоковая вершина, поэтому непонятно, как отличать ее среди прочих, а в автомате это бывает важно. Также сразу неясно, сколько состояний содержится в автомате в целом, поэтому проверка автомата на простоту оказывается нетривиальной.

Пример исходного языка:
```alphabet 100_105
start q0 q1 with 100_105
terminal q1
```
Пример, как можно было бы доработать язык -- добавлена строчка runoff и количество состояний автомата:

Пример доработанного языка:
```alphabet 100_105
states 3
start q0 q1 with 100_105
terminal q1
runoff q3
```

Хочется отметить, что в описании языка был приведен пример-иллюстрация автомата, что позволяет легче осознать происходящее в языке.
