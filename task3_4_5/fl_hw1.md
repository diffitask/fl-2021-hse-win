# Формальные языки
## Домашнее задание №1

#### Задание 3
В качестве рассматриваемого языка программирования мною был выбран C++. Нашла интересный и до сих пор мне не встречавшийся оператор _typeid_, которого, например, нет в языках С и Python, и тесно связанный с ним класс *type_info*.

**Синтаксис, как вызвать в программе:**

*typeid(some_object)*

**Что позволяет сделать?:**

Определить тип объекта во время выполнения.

**Что возвращает?**

*typeid* от объекта *some_object* возвращает ссылку на объект *type_info*, который, в свою очередь, описывает тип исходного объекта *some_object*;
то есть *typeid(some_object)* — это *const type_info&*.

**Когда может быть полезен?**

Обычно возникает в темах наследования и полиморфизме классов (напоминание: класс называется полиморфным, если в нем есть хотя бы одна виртуальная функция). typeid используется в случаях, когда истинный тип объекта нельзя определить, опираясь только на информацию, полученную на этапе сборки (статическую). Проверка типа происходит во время выполнения программы, поэтому оператору удается определить истинный тип.
Например, если применить typeid к указателю полиморфного класса, вернется реальный тип объекта, на который он указывает (то есть если исходно объект был типа наследник Derived, typeid вернет type_info ссылку на Derived, хоть исходный указатель был дан на Base).

**Конкретные варианты применения:**

к ссылке на класс
к указателю
к указателю в индексе ([])

**Пример использования:**
```
#include <iostream>
#include <typeinfo>

class Base {
public:
   virtual void vvfunc() {}
};

class Derived : public Base {};

using namespace std;
int main() {
   Derived* pd = new Derived;
   Base* pb = pd;
   cout << typeid( pb ).name() << endl;   //prints "class Base *"
   cout << typeid( *pb ).name() << endl;   //prints "class Derived"
   cout << typeid( pd ).name() << endl;   //prints "class Derived *"
   cout << typeid( *pd ).name() << endl;   //prints "class Derived"
   delete pd;
}
```

Про *type_info*:

**Что такое?**

Класс, описывающий сведения о типе, которые созданы в программе комиплятором. Класс хранит закодированное значение, позволяющее сравнивать различные типы на равенство и неравенство с помощью стандартных операторов == и !=. Также значение позволяет сортировать объекты в зависимости от их типов.

**Интерфейс класса:**
```
class type_info {
public:
    type_info(const type_info& rhs) = delete; // cannot be copied
    virtual ~type_info();
    size_t hash_code() const;
    _CRTIMP_PURE bool operator==(const type_info& rhs) const;
    type_info& operator=(const type_info& rhs) = delete; // cannot be copied
    _CRTIMP_PURE bool operator!=(const type_info& rhs) const;
    _CRTIMP_PURE int before(const type_info& rhs) const;
    size_t hash_code() const noexcept;
    _CRTIMP_PURE const char* name() const;
    _CRTIMP_PURE const char* raw_name() const;
};
```


#### Задание 4
*«Придумать язык для описания конечных автоматов»*

Описание на естественном языке:

По аналогии с определением конечного детерминированного автомата, учитывая, что автомат схож с графом, автомат будем описывать следующими параметрами (каждый параметр записывается на отдельной стороке, после мощности/ количества идет дефис):
1. Мощность алфавита, затем перечисление всех его символов
2. Мощность множества состояний
3. Начальное состояние, то есть номер вершины графа, соответствующей ей
4. Мощность множества терминальных вершин, затем перечисление номеров всех терминальных вершин
5. Количество переходов между состояниями, затем перечисление всех ребер-переходов между состояниями. Ребро описывается своей начальной и конечной вершинами, а также набором символов из алфавита, с помощью которых осуществляется этот переход.

**Пример 1**

Автомат, принимающий стоки, состоящие из букв a и b.
```
 Alphabet: 2 -- (a, b)
 Q: 2
 start: 0
 T: 1 -- 1
 edges: (0; 1; a, b)
```
**Пример 2**

Автомат, принимающий неотрицательные числа, делящиеся на 3 (лидирующие нули разрешаются).
```
Alphabet: 10 -- (1, 2, 3, 4, 5, 6, 7, 8, 9)
Q: 3
start: 0
T: 1 -- 0
edges: (0; 0; 0, 3, 6, 9), (0; 1; 1, 4, 7), (1; 0; 2, 5, 8), (1; 1; 0, 3, 6, 9), (1; 2; 1, 4, 7), (2; 1; 2, 5, 8), (2; 2; 0, 3, 6, 9), (2; 0; 1, 4, 7), (0; 2; 2, 5, 8)
```
**Пример 3**

Автомат, принимающий числа, в записи которых встречаются только четные цифры (лидирующие нули разрешаются).
```
Alphabet: 10 -- (1, 2, 3, 4, 5, 6, 7, 8, 9)
Q: 4
start: 0
T: 1 -- 0
edges: (0; 1; 0, 2, 4, 6, 8), (1; 1; 0, 2, 4, 6, 8), (1; 2; 1, 3, 5, 7, 9), (0; 2; 1, 3, 5, 7, 9), (2; 3; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9), (3; 3; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
```

#### Задание 5
В приведенном файле выполнена подсветка примера №2 из задания 4 для придуманного языка для описания конечных автоматов. Выделены комментарии, числа, отвечающие за размеры множеств, ключевые слова и названия множеств.
